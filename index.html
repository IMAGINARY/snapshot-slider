<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>SNAPSHOT slider</title>
    <!-- Link Swiper's CSS -->
    <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="node_modules/bootstrap-progressbar/css/bootstrap-progressbar-3.3.4.min.css">
    <link rel="stylesheet" href="libs/jqbtk.min.css">
    <link rel="stylesheet" href="node_modules/swiper/dist/css/swiper.min.css">
    <link rel="stylesheet" href="node_modules/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="node_modules/animate.css/animate.min.css">
    <link rel="stylesheet" href="main.css">

    <!-- load some node.js packages -->
    <script>
        var _ = require('lodash');
        var Promise = require("bluebird");
        var packageJson = require('./package.json');
        var semver = require('semver');
        remote = require('electron').remote;
        window.validateJSON = require('jsonschema').validate;
        window.settings = require('electron-settings');
        var miscConfig = settings.getSync("");
        var articles = _.cloneDeep(miscConfig.snapshots.articles);
        var mailConfig = miscConfig.mail;
        if (typeof mailConfig.text !== "undefined" && mailConfig.text !== null)
            mailConfig.text = mailConfig.text.join("\n");
        if (typeof mailConfig.html !== "undefined" && mailConfig.html !== null)
            mailConfig.html = mailConfig.html.join("\n");

        window.$ = window.jQuery = require("jquery");
        require('bootstrap');
        require('bootstrap-notify');
        window.bootbox = require('bootbox');
        require("swiper");
        window.qrImage = require("qr-image");

        window.nodemailer = require('nodemailer');
        window.htmlToText = require('html-to-text');
        window.format = require('string-template');

        require("pdfjs-dist");
        window.PDFJS.workerSrc = 'node_modules/pdfjs-dist/build/pdf.worker.js';

        // create reusable transporter object using the default SMTP transport
        window.transporter = nodemailer.createTransport(mailConfig.smtp);

        // verify connection configuration
        transporter.verify(function(error, success) {
            if (error) {
                console.log(error);
            } else {
                console.log('Server is ready to take our messages');
            }
        });

        window.fs = require('fs');
        window.fsExtra = require('fs-extra');
        window.path = require('path');
        window.hashFiles = function(options) {
            return new Promise((resolve, reject) => hashFiles._hashFilesNodeBack(options, (err, hash) => err ? reject(err) : resolve(hash)));
        };
        window.hashFiles._hashFilesNodeBack = require('hash-files');
        window.childProcess = require('child_process');
        var request = require('request');
        var hummus = require('hummus');
        var streamBuffers = require('stream-buffers');
        var printer = require('printer');

        var pdfCacheDirname = path.join(path.dirname(settings.getSettingsFilePath()), "pdfCache");
        var pngCacheDirname = path.join(path.dirname(settings.getSettingsFilePath()), "pngCache");
        fsExtra.mkdirpSync(pdfCacheDirname, {
            mode: fs.statSync(path.dirname(settings.getSettingsFilePath())).mode
        });
        fsExtra.mkdirpSync(pngCacheDirname, {
            mode: fs.statSync(path.dirname(settings.getSettingsFilePath())).mode
        });

        function download(url, dest) {
            return new Promise((resolve, reject) => {
                console.log(`Downloading ${url} to ${dest}`);
                var file = fs.createWriteStream(dest);
                var sendReq = request.get(url);

                // verify response code
                sendReq.on('response', response => {
                    if (response.statusCode !== 200)
                        reject(response.statusCode);
                });

                // check for request errors
                sendReq.on('error', err => {
                    fs.unlink(dest);
                    reject(err);
                }); // Delete the file async. (But we don't check the result)

                sendReq.pipe(file);

                file.on('finish', () => file.close(() => resolve(dest))); // close() is async, call resolve after close completes.
                file.on('error', err => {
                    fs.unlink(dest);
                    reject(err);
                }); // Delete the file async. (But we don't check the result)
            });
        };

        function createPDF2On1(infile, outfileOrStream, pagesNumbers) {
            console.log(`Creating 2-on-1 version of ${infile} at ${outfileOrStream}`);
            if (typeof outfileOrStream !== 'string')
                outfileOrStream = new hummus.PDFStreamForResponse(outfileOrStream);
            var pdfWriter = hummus.createWriter(outfileOrStream, {
                version: eval("hummus.ePDFVersion" + hummus.createReader(infile).getPDFLevel() * 10)
            });
            var copyingContext = pdfWriter.createPDFCopyingContext(infile);
            var numPages = copyingContext.getSourceDocumentParser().getPagesCount();
            var pagesNumbers = (typeof pagesNumbers !== 'undefined') ? pagesNumbers : Array.from(Array(numPages), (_, i) => i);

            for (var i = 0; i < pagesNumbers.length;) {
                var page = pdfWriter.createPage(0, 0, 842, 595);
                var pageContent = pdfWriter.startPageContentContext(page);

                if (pagesNumbers[i] >= 0) {
                    pageContent.q().cm(1, 0, 0, 1, 0, 0);
                    copyingContext.mergePDFPageToPage(page, pagesNumbers[i]);
                    pageContent.Q();
                }
                ++i;
                if (i < pagesNumbers.length && pagesNumbers[i] >= 0) {
                    pageContent.q().cm(1, 0, 0, 1, 421, 0);
                    copyingContext.mergePDFPageToPage(page, pagesNumbers[i]);
                    pageContent.Q();
                }
                ++i;

                pdfWriter.writePage(page);
            }

            pdfWriter.end();
        }

        function createPDFBooklet(infile, outfileOrStream, shiftLastPageToBackCover = true) {
            console.log(`Creating booklet version of ${infile} at ${outfileOrStream}`);
            var numPages = hummus.createReader(infile).getPagesCount();
            var numBookletPages = Math.ceil(numPages / 4) * 4;

            // compute bookelt page numbers
            var pageNumbers = Array(0);
            var segment = [numBookletPages - 1, 0, 1, numBookletPages - 2];
            for (var i = 0; i < numBookletPages / 4; ++i) {
                pageNumbers = pageNumbers.concat(segment);
                segment = [segment[0] - 2, segment[1] + 2, segment[2] + 2, segment[3] - 2];
            }

            // move last page of input to last page of booklet if required
            if (shiftLastPageToBackCover) {
                pageNumbers = pageNumbers.map(i => i >= numPages - 1 ? -1 : i);
                pageNumbers[0] = numPages - 1;
            } else {
                pageNumbers = pageNumbers.map(i => i > numPages - 1 ? -1 : i);
            }
            createPDF2On1(infile, outfileOrStream, pageNumbers);
        }
    </script>
    <script src="libs/jqbtk.js"></script>
</head>

<body class="noselect">

    <div id="full-hd-centered">
        <!-- Swiper -->
        <div class="swiper-container swiper-container-h" id="slider">
            <div class="swiper-wrapper">
            </div>
        </div>
    </div>

    <template id="progressTemplate">
        <div class="progress">
            <span class="progressbar-back-text"></span>
            <div id="progressCache" class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="0" aria-valuenow="0" style="width:0%;" template="{0} of {1} documents cached">
                <span class="progressbar-front-text"></span>
            </div>
        </div>
        <div class="progress">
            <span class="progressbar-back-text"></span>
            <div id="progressDocs" class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="0" aria-valuenow="0" style="width:0%" template="{0} of {1} documents initialized">
                <span class="progressbar-front-text"></span>
            </div>
        </div>
        <div class="progress">
            <span class="progressbar-back-text"></span>
            <div id="progressPages" class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="0" aria-valuenow="0" style="width:0%" template="{0} of {1} pages loaded">
                <span class="progressbar-front-text"></span>
            </div>
        </div>
        <div class="progress">
            <span class="progressbar-back-text"></span>
            <div id="progressRendered" class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="0" aria-valuenow="0" style="width:0%" template="{0} of {1} pages cached">
                <span class="progressbar-front-text"></span>
            </div>
        </div>
    </template>
    <script>
        var initNotification;

        function initInitNotification() {
            return new Promise((resolve, reject) => {
                    initNotification = $.notify({
                        icon: "fa fa-circle-o-notch fa-spin fa-fw",
                        title: "Initializing …",
                        message: '<div id="progress"></div>'
                    }, {
                        placement: {
                            from: "bottom",
                            align: "right"
                        },
                        animate: {
                            enter: 'animated fadeInRight',
                            exit: 'animated fadeOutRight'
                        },
                        delay: 0,
                        onShow: resolve,
                        allow_dismiss: false
                    })
                })
                .then(() => $("#progress").append($("#progressTemplate")[0].content.children))
                .then(() => ["#progressCache", "#progressDocs", "#progressPages", "#progressRendered"].forEach(e => updateProgressBar(e)));
        }

        function updateProgressBar(progressBar, data) {
            $progressBar = $(progressBar);

            if (typeof data === "object" || typeof data === "function") {
                ["min", "max", "now"].forEach((e, i, a) => {
                    if (data.hasOwnProperty(e)) {
                        if (data.offset === true)
                            increaseAttr($progressBar, `aria-value${e}`, data[e]);
                        else
                            $progressBar.attr(`aria-value${e}`, data[e]);
                    }
                });
            }

            var min = $progressBar.attr("aria-valuemin");
            var max = $progressBar.attr("aria-valuemax");
            var now = $progressBar.attr("aria-valuenow");
            var percentage = 100 * (now - min) / (max - min);
            $progressBar.css("width", `${percentage}%`);

            $frontText = $progressBar.find(".progressbar-front-text");
            $frontText.css("width", $progressBar.parent().css("width"));
            $frontText.text(format($progressBar.attr("template"), now, max));
            $backText = $progressBar.parent().find(".progressbar-back-text");
            $backText.text(format($progressBar.attr("template"), now, max));
        }

        function increaseAttr(selector, attr, amount) {
            $(selector).attr(attr, parseInt($(selector).attr(attr), 10) + amount);
        }

        var _openNotifications = {};
        function _notify(icon, title, message, details, type) {
            this.id = typeof this.id === "undefined" ? this.id = 0 : this.id + 1;
            var currId = this.id;

            console.log({
                id: this.id,
                type: type,
                title: title,
                message: message,
                details: details
            });

            var detailsHTML = ""
            if (!(typeof details === "undefined")) {
                if (details instanceof Error)
                    details = details.stack;
                else if (details instanceof Object)
                    details = JSON.stringify(details, null, 2);

                detailsHTML =
                    `
                    <i class="fa fa-caret-down" aria-hidden="true" onClick="$('#collapsibleDetails${currId}').on('shown.bs.collapse',()=>_openNotifications[${currId}].update({}));$('#collapsibleDetails${currId}').collapse('show');$(this).css('display','none');$(this).next().css('display','');"></i>
                    <i class="fa fa-caret-up" aria-hidden="true" style="display: none;" onClick="$('#collapsibleDetails${currId}').on('hidden.bs.collapse',()=>_openNotifications[${currId}].update({}));$('#collapsibleDetails${currId}').collapse('hide');$(this).css('display','none');$(this).prev().css('display','');"></i>
                    <div id="collapsibleDetails${currId}" class="collapse">
                        <pre class="notifyDetails">${details}</pre>
                    </div>
                `;
            }

            return new Promise((resolve, reject) => _openNotifications[currId] = $.notify({
                icon: icon,
                title: title,
                message: typeof message === 'undefined' ? "" : message + detailsHTML
            }, {
                type: type,
                placement: {
                    from: "bottom",
                    align: "right"
                },
                animate: {
                    enter: 'animated fadeInRight',
                    exit: 'animated fadeOutRight'
                },
                onClosed: () => {
                    delete _openNotifications[currId];
                    resolve();
                },
                delay: 4000,
                mouse_over: 'pause'
            }));
        }

        var notifySuccess = (title, message, details) => _notify("fa fa-check-square", title, message, details, "success");
        var notifyInfo = (title, message, details) => _notify("fa fa-info-circle", title, message, details, "info");
        var notifyWarning = (title, message, details) => _notify("fa fa-exclamation-triangle", title, message, details, "warning");
        var notifyError = (title, message, details) => _notify("fa fa-exclamation-circle", title, message, details, "danger");
    </script>

    <script>
        var swiper;
        var swiperInitialSlide;
        var nestedSwipers = [];

        if (miscConfig.hideCursor) {
            var lastCSS = document.styleSheets[document.styleSheets.length - 1];
            lastCSS.insertRule("* { cursor: none; }", lastCSS.cssRules.length);
        }

        window.onresize = e => {
            var sx = $(window).width() / 1920;
            var sy = $(window).height() / 1080;
            var s = Math.min(sx, sy);
            var fullHdCentered = document.getElementById("full-hd-centered");
            fullHdCentered.style.transform = `scale(${s})`;
            fullHdCentered.style.left = `${($(window).width()-1920*s)/2.0}px`;
            fullHdCentered.style.top = `${($(window).height()-1080*s)/2.0}px`;
        }
        window.onresize();

        document.body.ondblclick = e => {
            if (mode == "slider") {
                var win = remote.getCurrentWindow();
                var sx = win.getContentSize()[0] / 1920;
                var sy = win.getContentSize()[0] / 1080;
                var s = Math.min(sx, sy);
                win.setContentSize(Math.floor(1920 * s), Math.floor(1080 * s), true);
            }
        }
        document.body.ondblclick();

        document.onkeydown = e => {
            if (mode == "slider") {
                const actions = {
                    "i": about,
                    "ArrowLeft": swiper.slidePrev, // left arrow
                    "ArrowRight": swiper.slideNext, // right arrow
                    "ArrowDown": nestedSwipers[swiper.realIndex].slideNext, // down arrow
                    "ArrowUp": nestedSwipers[swiper.realIndex].slidePrev // up arrow
                };
                actions[miscConfig.snapshots.autoUpdate.hotkey] = switchToUpdateMode;
                if (typeof actions[e.key] !== 'undefined')
                    actions[e.key]();
            }
        };

        function about() {
            notifyInfo(
                `About ${packageJson.productName}`,
                `License: ${packageJson.license}<br/>Version: ${packageJson.version}`,
                process.versions
            );
        }

        function rearrangeConfig() {
            if (miscConfig.snapshots.sort.enable) {
                var sortConfig = miscConfig.snapshots.sort;
                if (typeof sortConfig.by !== "undefined" && sortConfig.by != null)
                    sortConfig.compareFunction = `(a,b) => a.${sortConfig.by}.localeCompare(b.${sortConfig.by})`;
                articles = articles.sort(eval(sortConfig.compareFunction));
            }

            if (miscConfig.snapshots.filter.enable)
                articles = articles.filter(eval(miscConfig.snapshots.filter.filterFunction));

            // reverse order such that oldest items come first
            articles.reverse();

            // put overview page to the beginning
            var frontPage = settings.getSync("snapshots.frontPage");
            frontPage.isFrontPage = true;
            articles.unshift(frontPage);

            // move ~half of the slides from the end to the beginning
            for (swiperInitialSlide = 0; swiperInitialSlide < Math.floor(articles.length / 2); ++swiperInitialSlide) {
                var elem = articles.pop();
                articles.unshift(elem);
            }
        }

        function fileExists(filePath) {
            try {
                return fs.statSync(filePath).isFile();
            } catch (err) {
                return false;
            }
        }

        function initCache(which) {
            var article = articles[which];
            article.cachedPdf = path.join(pdfCacheDirname, `${article.sha256}.pdf`);
            var hashOptions = {
                files: [article.cachedPdf],
                algorithm: 'sha256'
            };
            return hashFiles(hashOptions).then(sha256 => {
                if (sha256 == article.sha256) {
                    return Promise.resolve(which);
                } else {
                    console.log("sha256 does not match for", article, "trying to download the file (again)");
                    return download(article.pdf, article.cachedPdf).then(() => {
                        return hashFiles(hashOptions).then(newSha256 => newSha256 == article.sha256 ? Promise.resolve(which) : Promise.reject(new Error(`unable to cache ${article.pdf} at ${article.cachedPdf}`)));
                    });
                }
            });
        }

        function initTopLevelSlides() {
            for (var i = 0; i < articles.length; ++i) {
                const slide = document.createElement("DIV");
                slide.classList.add("swiper-slide");
                slide.classList.add("swiper-slide-h");
                $("#slider").children(".swiper-wrapper").first().append(slide);
                const $slide_wrapper = $('<div/>', {
                    class: 'slide-wrapper'
                });
                $(slide).append($slide_wrapper);

                const verticalSwiper = $('<div class="swiper-container swiper-container-v" style="transform: translateZ(0);"><div class="swiper-wrapper"></div></div>');

                const isFrontPage = typeof articles[i].isFrontPage != 'undefined' && articles[i].isFrontPage == true;

                $slide_wrapper.append(verticalSwiper);
                const buttonBar = $slide_wrapper.append(`<div id="button-bar-${i}" class="button-bar"></div>`).children().last();

                if (!miscConfig.mail.enable)
                    buttonBar.append(`<i class="fa fa-envelope-o disabled" aria-hidden="true"></i>`);
                else
                    buttonBar.append(`<a href="javascript:switchToMailMode(${i});"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>`);

                if (isFrontPage || !miscConfig.print.enable)
                    buttonBar.append(`<i class="fa fa-print disabled" aria-hidden="true"></i>`);
                else
                    buttonBar.append(`<a href="javascript:switchToPrintMode(${i});"><i class="fa fa-print" aria-hidden="true"></i></a>`);

                // add QR code
                var svgObject = $(qrImage.imageSync(articles[i].url_short, {
                    type: 'svg',
                    size: 2
                }));
                svgObject.addClass("qrcode");
                $(`#button-bar-${i}`).append(svgObject);
                if (isFrontPage)
                    $(`#button-bar-${i}`).addClass('overview');
            }
        }

        function initNestedSlides(which) {
            var nestedSwiper = nestedSwipers[which];
            var promises = [];
            for (var pageNum = 1; pageNum <= documents[which].numPages; ++pageNum) {
                const loader = document.createElement("div");
                loader.classList.add("loader");
                const div = document.createElement("div");
                div.appendChild(loader);
                div.classList.add("swiper-slide");
                div.classList.add("swiper-slide-v");
                div.style.height = `${nestedSwiper.width}px`;

                nestedSwiper.appendSlide(div);

                const thisPageNum = pageNum;
                articles[which].cachedPng = new Array(documents[which].numPages);
                var pdfBasename = path.basename(articles[which].pdf, ".pdf");
                var pagePromise = documents[which].getPage(thisPageNum).then(page => {
                    updateProgressBar("#progressPages", {
                        now: 1,
                        offset: true
                    });

                    var viewport = page.getViewport(1);
                    var scale = nestedSwiper.width / viewport.width;
                    var scaledViewport = page.getViewport(scale);
                    scaledViewport.width = Math.floor(scaledViewport.width);
                    scaledViewport.height = Math.floor(scaledViewport.height);

                    // fix dimensions of slide
                    div.style.width = `${scaledViewport.width}px`;
                    div.style.height = `${scaledViewport.height}px`;
                    nestedSwiper.update(true);

                    // determine filename of PNG image cache
                    var cachedPng = path.join(pngCacheDirname, `${pdfBasename}.${thisPageNum}.${scaledViewport.width}x${scaledViewport.height}.png`);
                    articles[which].cachedPng[thisPageNum - 1] = cachedPng;

                    // create PNG cache image if it's not already there
                    var cachePromise;
                    if (fileExists(cachedPng))
                        cachePromise = Promise.resolve();
                    else {
                        const canvas = document.createElement("CANVAS");
                        canvas.style.transform = 'translateZ(0)';
                        canvas.width = scaledViewport.width;
                        canvas.height = scaledViewport.height;

                        var context = canvas.getContext("2d", {
                            alpha: false
                        });
                        var renderContext = {
                            canvasContext: context,
                            viewport: scaledViewport
                        };

                        cachePromise = page.render(renderContext).then(() => {
                            var pngDataBase64 = canvas.toDataURL().substr("data:image/png;base64,".length);
                            var pngBuffer = Buffer.from(pngDataBase64, "base64");
                            return new Promise((resolve, reject) => {
                                fs.writeFile(cachedPng, pngBuffer, err => err ? reject(err) : resolve());
                            });
                        });
                    }
                    return cachePromise.then(() => updateProgressBar("#progressRendered", {
                        now: 1,
                        offset: true
                    }));
                });
                promises.push(pagePromise);
            }
            return Promise.all(promises);
        }

        var initComplete = false;

        function initSliders() {
            var lastActiveIndex = -1;
            var triggerAgain;
            var callback = function() {
                if (lastActiveIndex != swiper.activeIndex && initComplete) {
                    console.log("reassigning slides");
                    $(swiper.slides).css("visibility", "hidden");
                    var imagesToRemove = $(swiper.slides).find("img");
                    var imagesAdded = 0;
                    for (var i = swiper.activeIndex - 3; i <= swiper.activeIndex + 3; i++) {
                        const slide = swiper.slides[i % swiper.slides.length];
                        slide.style.visibility = "visible";
                        const tlSlideIndex = slide.getAttribute("data-swiper-slide-index");
                        const nestedSwiper = nestedSwipers[tlSlideIndex].container[0];

                        nestedSwipers[tlSlideIndex].slides.each((j, nestedSlide) => {
                            var image = $(nestedSlide).find("img");
                            if (image.length == 0) {
                                ++imagesAdded;
                                image = new Image();
                                image.onload = () => {
                                    while (nestedSlide.firstChild)
                                        nestedSlide.removeChild(nestedSlide.firstChild);
                                    nestedSlide.appendChild(image);
                                };
                                image.src = articles[tlSlideIndex].cachedPng[j];
                            }
                            imagesToRemove = imagesToRemove.not(image);
                        });

                        slide.getElementsByClassName("slide-wrapper")[0].appendChild(nestedSwiper);
                        console.log(slide.getAttribute("data-swiper-slide-index") + " -> " + i % swiper.slides.length);
                    }
                    imagesToRemove.remove();
                    console.log(`${imagesAdded} images added, ${imagesToRemove.length} removed`);
                    lastActiveIndex = swiper.activeIndex;
                }
                if (triggerAgain)
                    window.requestAnimationFrame(callback);
            }

            var swiperConfig = {
                direction: 'horizontal',
                slidesPerView: 'auto',
                freeMode: true,
                effect: 'coverflow',
                //mousewheelControl: true,
                //mousewheelForceToAxis: true,
                spaceBetween: 78,
                initialSlide: swiperInitialSlide,
                loop: true,
                loopedSlides: articles.length,
                freeModeSticky: true,
                freeModeMomentumRatio: 0.25,
                centeredSlides: true,
                onSlideChangeStart: function(swiper) {
                    triggerAgain = true;
                    window.requestAnimationFrame(callback);
                },
                onSlideChangeEnd: function(swiper) {
                    triggerAgain = true;
                },
            };
            swiper = new Swiper('#slider', swiperConfig);
            for (var i = 0; i < swiper.slides.length; i++)
                $(swiper.slides[i]).attr("data-swiper-fake-slide-index", i);

            var nestedSwiperConfig = {
                direction: 'vertical',
                slidesPerView: 'auto',
                spaceBetween: 4,
                freeMode: true,
                freeModeSticky: true,
                mousewheelControl: true,
                mousewheelForceToAxis: true,
                controlBy: 'container'
            };
            $(swiper.slides).not('.swiper-slide-duplicate').find('.swiper-container').each(function() {
                nestedSwipers.push(new Swiper(this, nestedSwiperConfig));
            });
            $(swiper.slides).filter('.swiper-slide-duplicate').find('.swiper-container').remove();
        }

        var documents = new Array(articles.length);
        var totalNumPages = 0;

        function initDocument(which) {
            return PDFJS.getDocument(articles[which].cachedPdf).promise.then(function(pdf) {
                documents[which] = pdf;
                totalNumPages += pdf.numPages;
                return which;
            });
        }

        function disableSnapshot(index) {
            // disable mail and print buttons
            $(`#button-bar-${index} a > i`).unwrap();
            $(`#button-bar-${index} i`).addClass("disabled");
        }

        function initIdleHandlers() {
            var idle_timer = null;
            var init_idle_timer = function(delay) {
                if (idle_timer != null)
                    clearTimeout(idle_timer);
                idle_timer = setTimeout(idle_handler, delay);
            }
            var non_idle_handler = function(evt) {
                console.log("non_idle_handler");
                init_idle_timer(miscConfig.idleModeDelayMs);
            }
            var idle_handler = function() {
                console.log("idle_handler");
                idleAction();
                init_idle_timer(miscConfig.idleModeDelayBetweenActionsMs);
            }

            document.body.addEventListener('mouseup', non_idle_handler, true);
            document.body.addEventListener('mousemove', non_idle_handler, true);
            document.body.addEventListener('mousedown', non_idle_handler, true);
            document.body.addEventListener("touchstart", non_idle_handler, true);
            document.body.addEventListener("touchend", non_idle_handler, true);
            document.body.addEventListener("touchcancel", non_idle_handler, true);
            document.body.addEventListener("touchmove", non_idle_handler, true);
            document.body.addEventListener("onscroll", non_idle_handler, true);
            document.body.addEventListener("keydown", non_idle_handler, true);
            document.body.addEventListener("keyup", non_idle_handler, true);
            document.body.addEventListener("keypress", non_idle_handler, true);

            init_idle_timer(miscConfig.idleModeDelayMs);
        }

        function idleAction() {
            bootbox.hideAll();
            nestedSwipers[(swiper.activeIndex + 2) % articles.length].slideTo(0, 0);
            swiper.slideNext(true, miscConfig.idleAnimationDurationMs);
        }

        var mode;

        function switchToSlider() {
            mode = "slider";
            $('#slider').show();
        }

        function switchToUpdateMode() {
            mode = "update";

            bootbox.confirm({
                title: 'Confirm update',
                message: '<p class="dialog">Are you sure that you want to update the list of available SNAPSHOTS?<p>',
                callback: function(result) {
                    if (result)
                        updateSnapshotList();
                    switchToSlider();
                }
            });
        }

        function updateSnapshotList() {
            var errorNotificationTitle = "Update of SNAPSHOT list failed";
            var successNotificationTitle = "Update of SNAPSHOT list successful";

            return new Promise((resolve, reject) => {
                request.get({
                    url: miscConfig.snapshots.autoUpdate.url,
                }, (err, res, body) => {
                    if (err) {
                        notifyError(errorNotificationTitle, "The list could not be downloaded.", err);
                        reject(err);
                    } else if (res.statusCode !== 200) {
                        notifyError(errorNotificationTitle, "The list could not be downloaded.", `Unexpected HTTP status code${res.statusCode}`);
                        reject(res.statusCode);
                    } else {
                        try {
                            var json = JSON.parse(body);

                            var expectedSemVer = '1.x';
                            if (json.version && !semver.satisfies(json.version, '1.x')) {
                                var versionError = new Error(`Semantic version mismatch.\nExpected: ${expectedSemVer}\nSupplied: ${json.version}`);
                                notifyError(errorNotificationTitle, `Version mismatch: ${json.version} vs. ${expectedSemVer}`, versionError);
                                reject(versionError);
                            } else {
                                var schema = {
                                    type: "object",
                                    properties: {
                                        "version": {
                                            type: "string",
                                            required: true
                                        },
                                        "snapshots": {
                                            type: "array",
                                            required: true,
                                            items: {
                                                type: "object",
                                                properties: {
                                                    "title": {
                                                        type: "string",
                                                        required: true
                                                    },
                                                    "url": {
                                                        type: "string",
                                                        required: true,
                                                        format: "uri"
                                                    },
                                                    "url_short": {
                                                        type: "string",
                                                        required: true,
                                                        format: "uri"
                                                    },
                                                    "pdf": {
                                                        type: "string",
                                                        required: true,
                                                        format: "uri"
                                                    },
                                                    "sha256": {
                                                        type: "string",
                                                        required: true,
                                                        pattern: /^[0-9a-f]{64}$/
                                                    },
                                                    "authors": {
                                                        type: "array",
                                                        required: true,
                                                        items: {
                                                            type: "string"
                                                        }
                                                    },
                                                    "doi": {
                                                        type: "string",
                                                        required: true,
                                                        pattern: new RegExp('^(10[.][0-9]{4,}(?:[.][0-9]+)*/(?:(?![%"#? ])\\S)+)$')
                                                    }
                                                }
                                            }
                                        }
                                    }
                                };

                                validateJSON(json, schema, {
                                    throwError: true
                                });

                                if (_.isEqual(json.snapshots, miscConfig.snapshots.articles)) {
                                    notifySuccess(successNotificationTitle, "No change detected.", json);
                                    resolve();
                                } else {
                                    settings.set("snapshots.articles", json.snapshots, {
                                            prettify: true
                                        })
                                        .then(() => notifySuccess(successNotificationTitle, "Reloading …", json))
                                        .then(() => location.reload())
                                        .catch(err => {
                                            notifyError(errorNotificationTitle, "The list could not be written to the settings file.", err);
                                            reject(err);
                                        })
                                        .then(resolve);
                                }
                            }
                        } catch (jsonErr) {
                            notifyError(errorNotificationTitle, "The downloaded list is invalid.", jsonErr);
                            reject(jsonErr);
                        }
                    }
                });
            });
        }

        var recipientName = '';
        var recipientAddress = '';

        function switchToMailMode(which) {
            mode = "mail";
            bootbox.confirm({
                title: 'Please enter your email address',
                message: '<p>Select one of the input fields to open the on screen keyboard. Click outside the on screen keyboard to hide it.</p><br /><p><div class="form-group"><label for="emailName">Name:</label><input type="text" class="keyboard form-control" id="emailName"></div><div class="form-group"><label for="emailAddress">Email:</label><input type="text" class="keyboard form-control" id="emailAddress"></div></p>',
                callback: function(result) {
                    if (result) {
                        recipientName = $('#emailName').val().trim();
                        recipientAddress = $('#emailAddress').val().trim();
                        email(which);
                        recipientName = '';
                        recipientAddress = '';
                    }
                    switchToSlider();
                }
            });
            $("#emailName").keyboard();
            $("#emailAddress").keyboard();
        }

        function switchToPrintMode(which) {
            mode = "print";
            bootbox.confirm({
                title: 'Confirm printing',
                message: `<p class="dialog">Do you want to print: <em>"<b>${articles[which].authors.map( a => a.trim() ).join(", ")}:</b> ${articles[which].title.trim()}"</em>?<p>`,
                callback: function(result) {
                    if (result) {
                        print(which);
                    }
                    switchToSlider();
                }
            });
        }

        function print(which) {
            return new Promise((resolve, reject) => {
                    console.log('printing ' + path.basename(articles[which].cachedPdf));
                    streamBuffer = new streamBuffers.WritableStreamBuffer({
                        initialSize: (1000 * 1024), // start at 100 kilobytes.
                        incrementAmount: (100 * 1024) // grow by 10 kilobytes each time buffer overflows.
                    });
                    createPDFBooklet(articles[which].cachedPdf, streamBuffer);
                    printer.printDirect({
                        data: streamBuffer.getContents(),
                        docname: path.basename(articles[which].cachedPdf),
                        type: 'PDF',
                        options: {
                            landscape: true,
                            PageSize: 'A4',
                            Duplex: 'DuplexTumble'
                        },
                        success: resolve,
                        error: reject
                    });
                })
                .then(() => notifySuccess('File has been sent to the printer'))
                .catch(error => notifyError('Print job failed', 'Please check the error message', error));
        }

        function email(which) {
            var c = articles[which];

            console.log('mailing ' + c.url + ' to ' + recipientAddress);

            const substUrls = function(s) {
                return format(s, {
                    websiteUrl: c.url,
                    pdfUrl: c.pdf,
                    defaultRecipientName: recipientName != '' ? recipientName : mailConfig.defaultRecipientName
                });
            };

            var formattedHtml = substUrls(mailConfig.html);
            var formattedText = typeof mailConfig.text !== 'undefined' && mailConfig.text != null ? substUrls(mailConfig.text) : htmlToText.fromString(formattedHtml, {
                hideLinkHrefIfSameAsText: true
            });

            // setup e-mail data with unicode symbols
            var mailOptions = {
                from: {
                    name: mailConfig.senderName,
                    address: mailConfig.senderAddress
                }, // sender address
                to: recipientName == '' ? recipientAddress : {
                    name: recipientName,
                    address: recipientAddress
                }, // list of receivers
                subject: mailConfig.subject, // subject line
                text: formattedText, // plaintext body
                html: formattedHtml, // html body
            };

            // send mail with defined transport object
            transporter.sendMail(mailOptions, function(error, info) {
                if (error) {
                    notifyError('Email could not be sent', 'Please check the error message', error);
                } else {
                    notifySuccess('Email sent successfully', "", info);
                }
            });
        }

        // GO!
        new Promise((resolve, reject) => $(document).ready(resolve))
            .then(miscConfig.snapshots.autoUpdate.enable ? () => {
                notifyInfo("Starting update of SNAPSHOT list");
                return updateSnapshotList().reflect();
            } : Promise.resolve())
            .then(initInitNotification)
            .then(() => {
                var startTime = performance.now()
                rearrangeConfig();
                updateProgressBar("#progressCache", {
                    max: articles.length
                });
                updateProgressBar("#progressDocs", {
                    max: articles.length
                });
                initTopLevelSlides();
                initSliders();
                var cachePDFPromises = [];
                var initDocumentPromises = [];
                var initNestedSlidesPromises = [];
                var initCompletePromises = [];
                articles.forEach((article, which, a) => {
                    var cachePromise = initCache(which).catch(e => {
                        notifyError("Initialization error", `Could not cache "${article.authors.join(", ")}: ${article.title}" (doi: ${article.doi})`, e);
                        throw e;
                    });
                    var initDocumentPromise = cachePromise.then(() => initDocument(which).catch(e => {
                        notifyError("Initialization error", `Failed to load "${article.authors.join(", ")}: ${article.title}" (doi: ${article.doi})`, e);
                        throw e;
                    }));
                    var initNestedSlidesPromise = initDocumentPromise.then(() => initNestedSlides(which).catchThrow(e => {
                        notifyError("Initialization error",
                            `Failed to render pages of "${article.authors.join(", ")}: ${article.title}" (doi: ${article.doi})`, e);
                        throw e;
                    }));

                    cachePromise.finally(() => updateProgressBar("#progressCache", {
                        now: 1,
                        offset: true
                    }));
                    initNestedSlidesPromise.finally(() => {
                        updateProgressBar("#progressDocs", {
                            now: 1,
                            offset: true
                        });
                        updateProgressBar("#progressPages", {
                            max: totalNumPages
                        });
                        updateProgressBar("#progressRendered", {
                            max: totalNumPages
                        });
                    });

                    var initCompletePromise = initNestedSlidesPromise.catch(e => {
                        disableSnapshot(which);
                        console.log("Problem processing snapshot", article, e);
                    });

                    cachePDFPromises.push(cachePromise);
                    initDocumentPromises.push(initDocumentPromise);
                    initNestedSlidesPromises.push(initNestedSlidesPromise);
                    initCompletePromises.push(initCompletePromise);
                });

                Promise.all(initNestedSlidesPromises).catch(() => notifyWarning("Initialization incomplete", "Some SNAPSHOTS will be unavailable."));
                Promise.all(initCompletePromises)
                    .delay(1000)
                    .then(() => initNotification.close())
                    .then(() => {
                        initComplete = true;
                        //$('#progress').hide();
                        initIdleHandlers();
                        switchToSlider();
                        console.log(`loading took ${(performance.now()-startTime)/1000.0}s`)
                    });
            });
    </script>
</body>

</html>
