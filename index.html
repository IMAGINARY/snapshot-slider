<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>SNAPSHOT slider</title>
    <!-- Link Swiper's CSS -->
    <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="libs/jqbtk.min.css">
    <link rel="stylesheet" href="node_modules/swiper/dist/css/swiper.min.css">
    <link rel="stylesheet" href="node_modules/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="node_modules/animate.css/animate.min.css">
    <link rel="stylesheet" href="main.css">

    <!-- load some node.js packages -->
    <script>
        var Promise = require("bluebird");
        remote = require('electron').remote;
        window.settings = require('electron-settings');
        settings.defaults(require("./defaults.json"));
        settings.applyDefaults({
            prettify: true
        });
        var miscConfig = settings.getSync("");
        var articles = miscConfig.snapshots.articles;
        var mailConfig = miscConfig.mail;
        if (typeof mailConfig.text !== "undefined" && mailConfig.text !== null)
            mailConfig.text = mailConfig.text.join("\n");
        if (typeof mailConfig.html !== "undefined" && mailConfig.html !== null)
            mailConfig.html = mailConfig.html.join("\n");

        window.$ = window.jQuery = require("jquery");
        require('bootstrap');
        require('bootstrap-notify');
        window.bootbox = require('bootbox');
        require("swiper");
        window.qrImage = require("qr-image");

        window.nodemailer = require('nodemailer');
        window.htmlToText = require('html-to-text');
        window.format = require('string-template');

        require("pdfjs-dist");
        window.PDFJS.workerSrc = 'node_modules/pdfjs-dist/build/pdf.worker.js';

        // create reusable transporter object using the default SMTP transport
        window.transporter = nodemailer.createTransport(mailConfig.smtp);

        // verify connection configuration
        transporter.verify(function(error, success) {
            if (error) {
                console.log(error);
            } else {
                console.log('Server is ready to take our messages');
            }
        });

        window.fs = require('fs');
        window.fsExtra = require('fs-extra');
        window.path = require('path');
        window.hashFiles = function(options) {
            return new Promise((resolve, reject) => hashFiles._hashFilesNodeBack(options, (err, hash) => err ? reject(err) : resolve(hash)));
        };
        window.hashFiles._hashFilesNodeBack = require('hash-files');
        window.childProcess = require('child_process');
        var request = require('request');
        var hummus = require('hummus');
        var streamBuffers = require('stream-buffers');
        var printer = require('printer');

        var pdfCacheDirname = path.join(path.dirname(settings.getSettingsFilePath()), "pdfCache");
        var pngCacheDirname = path.join(path.dirname(settings.getSettingsFilePath()), "pngCache");
        fsExtra.mkdirpSync(pdfCacheDirname, {
            mode: fs.statSync(path.dirname(settings.getSettingsFilePath())).mode
        });
        fsExtra.mkdirpSync(pngCacheDirname, {
            mode: fs.statSync(path.dirname(settings.getSettingsFilePath())).mode
        });

        function download(url, dest) {
            return new Promise((resolve, reject) => {
                console.log(`Downloading ${url} to ${dest}`);
                var file = fs.createWriteStream(dest);
                var sendReq = request.get(url);

                // verify response code
                sendReq.on('response', response => {
                    if (response.statusCode !== 200)
                        reject(new Error(`Download of ${url} failed with response code`));
                });

                // check for request errors
                sendReq.on('error', err => {
                    fs.unlink(dest);
                    reject(err);
                }); // Delete the file async. (But we don't check the result)

                sendReq.pipe(file);

                file.on('finish', () => file.close(() => resolve(dest))); // close() is async, call resolve after close completes.
                file.on('error', err => {
                    fs.unlink(dest);
                    reject(err);
                }); // Delete the file async. (But we don't check the result)
            });
        };

        function createPDF2On1(infile, outfileOrStream, pagesNumbers) {
            console.log(`Creating 2-on-1 version of ${infile} at ${outfileOrStream}`);
            if (typeof outfileOrStream !== 'string')
                outfileOrStream = new hummus.PDFStreamForResponse(outfileOrStream);
            var pdfWriter = hummus.createWriter(outfileOrStream, {
                version: eval("hummus.ePDFVersion" + hummus.createReader(infile).getPDFLevel() * 10)
            });
            var copyingContext = pdfWriter.createPDFCopyingContext(infile);
            var numPages = copyingContext.getSourceDocumentParser().getPagesCount();
            var pagesNumbers = (typeof pagesNumbers !== 'undefined') ? pagesNumbers : Array.from(Array(numPages), (_, i) => i);

            for (var i = 0; i < pagesNumbers.length;) {
                var page = pdfWriter.createPage(0, 0, 842, 595);
                var pageContent = pdfWriter.startPageContentContext(page);

                if (pagesNumbers[i] >= 0) {
                    pageContent.q().cm(1, 0, 0, 1, 0, 0);
                    copyingContext.mergePDFPageToPage(page, pagesNumbers[i]);
                    pageContent.Q();
                }
                ++i;
                if (i < pagesNumbers.length && pagesNumbers[i] >= 0) {
                    pageContent.q().cm(1, 0, 0, 1, 421, 0);
                    copyingContext.mergePDFPageToPage(page, pagesNumbers[i]);
                    pageContent.Q();
                }
                ++i;

                pdfWriter.writePage(page);
            }

            pdfWriter.end();
        }

        function createPDFBooklet(infile, outfileOrStream, shiftLastPageToBackCover = true) {
            console.log(`Creating booklet version of ${infile} at ${outfileOrStream}`);
            var numPages = hummus.createReader(infile).getPagesCount();
            var numBookletPages = Math.ceil(numPages / 4) * 4;

            // compute bookelt page numbers
            var pageNumbers = Array(0);
            var segment = [numBookletPages - 1, 0, 1, numBookletPages - 2];
            for (var i = 0; i < numBookletPages / 4; ++i) {
                pageNumbers = pageNumbers.concat(segment);
                segment = [segment[0] - 2, segment[1] + 2, segment[2] + 2, segment[3] - 2];
            }

            // move last page of input to last page of booklet if required
            if (shiftLastPageToBackCover) {
                pageNumbers = pageNumbers.map(i => i >= numPages - 1 ? -1 : i);
                pageNumbers[0] = numPages - 1;
            } else {
                pageNumbers = pageNumbers.map(i => i > numPages - 1 ? -1 : i);
            }
            createPDF2On1(infile, outfileOrStream, pageNumbers);
        }
    </script>
    <script src="libs/jqbtk.js"></script>
</head>

<body class="noselect">

    <div id="progress">
        PDF documents cached: <span id="progressCache" num="0" total="0">0</span>
        <br />PDF documents loaded: <span id="progressDocs" num="0" total="0">0</span>
        <br /> PDF pages loaded: <span id="progressPages" num="0" total="0">0</span>
        <br /> PDF pages rendered: <span id="progressRendered" num="0" total="0">0</span>
    </div>
    <script>
        {
            var update = node => node.innerHTML = node.getAttribute('num') + " of " + node.getAttribute('total');
            var mo = new MutationObserver(mutations =>
                mutations.forEach(m => update(m.target)));
            ["progressCache", "progressDocs", "progressPages", "progressRendered"].forEach(id => mo.observe(document.getElementById(id), {
                attributes: true
            }));
        }

        function increaseAttr(selector, attr, amount) {
            $(selector).attr(attr, parseInt($(selector).attr(attr), 10) + amount);
        }
    </script>

    <!-- Swiper -->
    <div class="swiper-container swiper-container-h" id="slider">
        <div class="swiper-wrapper">
        </div>
    </div>

    <div id="sendEmail">
        Send E-Mail
        <a href="javascript:switchToSlider()">Hide</a>
        <a id="mailButton" href="">Mail</a>
        <p>
            Name:
            <input id="recipientName" width="100" />
        </p>
        <p>
            Address:
            <input id="recipientAddress" width="100" />
        </p>
    </div>

    <script>
        var swiper;
        var swiperInitialSlide;
        var nestedSwipers = [];

        if (miscConfig.hideCursor) {
            var lastCSS = document.styleSheets[document.styleSheets.length - 1];
            lastCSS.insertRule("* { cursor: none; }", lastCSS.cssRules.length);
        }

        window.onresize = e => {
            var sx = $(window).width() / 1920;
            var sy = $(window).height() / 1080;
            var s = Math.min(sx, sy);
            var sc_h = document.getElementsByClassName("swiper-container-h")[0];
            sc_h.style.transform = `scale(${s})`;
            sc_h.style.left = `${($(window).width()-1920*s)/2.0}px`;
            sc_h.style.top = `${($(window).height()-1080*s)/2.0}px`;
        }
        window.onresize();

        document.body.ondblclick = e => {
            var win = remote.getCurrentWindow();
            var sx = win.getContentSize()[0] / 1920;
            var sy = win.getContentSize()[0] / 1080;
            var s = Math.min(sx, sy);
            win.setContentSize(Math.floor(1920 * s), Math.floor(1080 * s), true);
        }
        document.body.ondblclick();

        document.onkeydown = e => {
            const actions = {
                37: swiper.slidePrev, // left arrow
                39: swiper.slideNext, // right arrow
                40: nestedSwipers[swiper.realIndex].slideNext, // down arrow
                38: nestedSwipers[swiper.realIndex].slidePrev // up arrow
            }
            if (typeof actions[e.keyCode] !== 'undefined')
                actions[e.keyCode]();
        };

        function rearrangeConfig() {
            if (miscConfig.snapshots.sort.enable) {
                var sortConfig = miscConfig.snapshots.sort;
                if (typeof sortConfig.by !== "undefined" && sortConfig.by != null)
                    sortConfig.compareFunction = `(a,b) => a.${sortConfig.by}.localeCompare(b.${sortConfig.by})`;
                articles = articles.sort(eval(sortConfig.compareFunction));
            }

            if (miscConfig.snapshots.filter.enable)
                articles = articles.filter(eval(miscConfig.snapshots.filter.filterFunction));

            // reverse order such that oldest items come first
            articles.reverse();

            // put overview page to the beginning
            var frontPage = settings.getSync("snapshots.frontPage");
            frontPage.isFrontPage = true;
            articles.unshift(frontPage);

            // move ~half of the slides from the end to the beginning
            for (swiperInitialSlide = 0; swiperInitialSlide < Math.floor(articles.length / 2); ++swiperInitialSlide) {
                var elem = articles.pop();
                articles.unshift(elem);
            }
        }

        function fileExists(filePath) {
            try {
                return fs.statSync(filePath).isFile();
            } catch (err) {
                return false;
            }
        }

        var done = 0;
        var downloadMessage = "Downloading PDF files ({done} of {total})";
        var downloadProgress = $.notify({
            message: format(downloadMessage, {
                done: 0,
                total: articles.length
            }),
            progress: 0
        }, {
            showProgressbar: true,
            delay: 0
        });

        var updateProgress = () => {
            ++done;
            console.log(format(downloadMessage, {
                "done": done,
                "total": articles.length
            }));
            downloadProgress.update({
                message: format(downloadMessage, {
                    "done": done,
                    "total": articles.length
                }),
                progress: (100 * done) / articles.length
            });
        }

        function initCache(which) {
            var article = articles[which];
            article.cachedPdf = path.join(pdfCacheDirname, `${article.sha256}.pdf`);
            var hashOptions = {
                files: [article.cachedPdf],
                algorithm: 'sha256'
            };
            return hashFiles(hashOptions).then(sha256 => {
                if (sha256 == article.sha256) {
                    return Promise.resolve(which);
                } else {
                    console.log("sha256 does not match for", article, "trying to download the file (again)");
                    return download(article.pdf, article.cachedPdf).then(() => {
                        return hashFiles(hashOptions).then(newSha256 => newSha256 == article.sha256 ? Promise.resolve(which) : Promise.reject(new Error(`unable to cache ${article.pdf} at ${article.cachedPdf}`))).finally(updateProgress);
                    });
                }
            });
        }

        function initTopLevelSlides() {
            for (var i = 0; i < articles.length; ++i) {
                const slide = document.createElement("DIV");
                slide.classList.add("swiper-slide");
                slide.classList.add("swiper-slide-h");
                $("#slider").children(".swiper-wrapper").first().append(slide);
                const $slide_wrapper = $('<div/>', {
                    class: 'slide-wrapper'
                });
                $(slide).append($slide_wrapper);

                const verticalSwiper = $('<div class="swiper-container swiper-container-v" style="transform: translateZ(0);"><div class="swiper-wrapper"></div></div>');

                const isFrontPage = typeof articles[i].isFrontPage != 'undefined' && articles[i].isFrontPage == true;

                $slide_wrapper.append(verticalSwiper);
                const buttonBar = $slide_wrapper.append(`<div id="button-bar-${i}" class="button-bar"></div>`).children().last();

                if (!miscConfig.mail.enable)
                    buttonBar.append(`<i class="fa fa-envelope-o disabled" aria-hidden="true"></i>`);
                else
                    buttonBar.append(`<a href="javascript:switchToMailMode(${i});"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>`);

                if (isFrontPage || !miscConfig.print.enable)
                    buttonBar.append(`<i class="fa fa-print disabled" aria-hidden="true"></i>`);
                else
                    buttonBar.append(`<a href="javascript:switchToPrintMode(${i});"><i class="fa fa-print" aria-hidden="true"></i></a>`);

                // add QR code
                var svgObject = $(qrImage.imageSync(articles[i].url_short, {
                    type: 'svg',
                    size: 2
                }));
                svgObject.addClass("qrcode");
                $(`#button-bar-${i}`).append(svgObject);
                if (isFrontPage)
                    $(`#button-bar-${i}`).addClass('overview');
            }
        }

        function initNestedSlides(which) {
            var nestedSwiper = nestedSwipers[which];
            var promises = [];
            for (var pageNum = 1; pageNum <= documents[which].numPages; ++pageNum) {
                const loader = document.createElement("div");
                loader.classList.add("loader");
                const div = document.createElement("div");
                div.appendChild(loader);
                div.classList.add("swiper-slide");
                div.classList.add("swiper-slide-v");
                div.style.height = `${nestedSwiper.width}px`;

                nestedSwiper.appendSlide(div);

                const thisPageNum = pageNum;
                articles[which].cachedPng = new Array(documents[which].numPages);
                var pdfBasename = path.basename(articles[which].pdf, ".pdf");
                var pagePromise = documents[which].getPage(thisPageNum).then(page => {
                    increaseAttr("#progressPages", "num", 1);

                    var viewport = page.getViewport(1);
                    var scale = nestedSwiper.width / viewport.width;
                    var scaledViewport = page.getViewport(scale);
                    scaledViewport.width = Math.floor(scaledViewport.width);
                    scaledViewport.height = Math.floor(scaledViewport.height);

                    // fix dimensions of slide
                    div.style.width = `${scaledViewport.width}px`;
                    div.style.height = `${scaledViewport.height}px`;
                    nestedSwiper.update(true);

                    // determine filename of PNG image cache
                    var cachedPng = path.join(pngCacheDirname, `${pdfBasename}.${thisPageNum}.${scaledViewport.width}x${scaledViewport.height}.png`);
                    articles[which].cachedPng[thisPageNum - 1] = cachedPng;

                    // create PNG cache image if it's not already there
                    var cachePromise;
                    if (fileExists(cachedPng))
                        cachePromise = Promise.resolve();
                    else {
                        const canvas = document.createElement("CANVAS");
                        canvas.style.transform = 'translateZ(0)';
                        canvas.width = scaledViewport.width;
                        canvas.height = scaledViewport.height;

                        var context = canvas.getContext("2d", {
                            alpha: false
                        });
                        var renderContext = {
                            canvasContext: context,
                            viewport: scaledViewport
                        };

                        cachePromise = page.render(renderContext).then(() => {
                            var pngDataBase64 = canvas.toDataURL().substr("data:image/png;base64,".length);
                            var pngBuffer = Buffer.from(pngDataBase64, "base64");
                            return new Promise((resolve, reject) => {
                                fs.writeFile(cachedPng, pngBuffer, err => err ? reject(err) : resolve());
                            });
                        });
                    }
                    return cachePromise.then(() => increaseAttr("#progressRendered", "num", 1));
                });
                promises.push(pagePromise);
            }
            var result = Promise.all(promises);
            result.then(() => setTimeout(() => downloadProgress.close()));
            result.then(function() {
                $('#progressCache').html($('#progressCache').html() + '. done');
            });
            return result;
        }

        var initComplete = false;

        function initSliders() {
            var lastActiveIndex = -1;
            var triggerAgain;
            var callback = function() {
                if (lastActiveIndex != swiper.activeIndex && initComplete) {
                    console.log("reassigning slides");
                    $(swiper.slides).css("visibility", "hidden");
                    var imagesToRemove = $(swiper.slides).find("img");
                    var imagesAdded = 0;
                    for (var i = swiper.activeIndex - 3; i <= swiper.activeIndex + 3; i++) {
                        const slide = swiper.slides[i % swiper.slides.length];
                        slide.style.visibility = "visible";
                        const tlSlideIndex = slide.getAttribute("data-swiper-slide-index");
                        const nestedSwiper = nestedSwipers[tlSlideIndex].container[0];

                        nestedSwipers[tlSlideIndex].slides.each((j, nestedSlide) => {
                            var image = $(nestedSlide).find("img");
                            if (image.length == 0) {
                                ++imagesAdded;
                                image = new Image();
                                image.onload = () => {
                                    while (nestedSlide.firstChild)
                                        nestedSlide.removeChild(nestedSlide.firstChild);
                                    nestedSlide.appendChild(image);
                                };
                                image.src = articles[tlSlideIndex].cachedPng[j];
                            }
                            imagesToRemove = imagesToRemove.not(image);
                        });

                        slide.getElementsByClassName("slide-wrapper")[0].appendChild(nestedSwiper);
                        console.log(slide.getAttribute("data-swiper-slide-index") + " -> " + i % swiper.slides.length);
                    }
                    imagesToRemove.remove();
                    console.log(`${imagesAdded} images added, ${imagesToRemove.length} removed`);
                    lastActiveIndex = swiper.activeIndex;
                }
                if (triggerAgain)
                    window.requestAnimationFrame(callback);
            }

            var swiperConfig = {
                direction: 'horizontal',
                slidesPerView: 'auto',
                freeMode: true,
                effect: 'coverflow',
                //mousewheelControl: true,
                //mousewheelForceToAxis: true,
                spaceBetween: 78,
                initialSlide: swiperInitialSlide,
                loop: true,
                loopedSlides: articles.length,
                freeModeSticky: true,
                freeModeMomentumRatio: 0.25,
                centeredSlides: true,
                onSlideChangeStart: function(swiper) {
                    triggerAgain = true;
                    window.requestAnimationFrame(callback);
                },
                onSlideChangeEnd: function(swiper) {
                    triggerAgain = true;
                },
            };
            swiper = new Swiper('#slider', swiperConfig);
            for (var i = 0; i < swiper.slides.length; i++)
                $(swiper.slides[i]).attr("data-swiper-fake-slide-index", i);

            var nestedSwiperConfig = {
                direction: 'vertical',
                slidesPerView: 'auto',
                spaceBetween: 4,
                freeMode: true,
                freeModeSticky: true,
                mousewheelControl: true,
                mousewheelForceToAxis: true,
                controlBy: 'container'
            };
            $(swiper.slides).not('.swiper-slide-duplicate').find('.swiper-container').each(function() {
                nestedSwipers.push(new Swiper(this, nestedSwiperConfig));
            });
            $(swiper.slides).filter('.swiper-slide-duplicate').find('.swiper-container').remove();
        }

        var documents = new Array(articles.length);
        var totalNumPages = 0;

        function initDocument(which) {
            return PDFJS.getDocument(articles[which].cachedPdf).promise.then(function(pdf) {
                documents[which] = pdf;
                totalNumPages += pdf.numPages;
                return which;
            });
        }

        function disableSnapshot(index) {
            // disable mail and print buttons
            $(`#button-bar-${index} a > i`).unwrap();
            $(`#button-bar-${index} i`).addClass("disabled");
        }

        function initIdleHandlers() {
            var idle_timer = null;
            var init_idle_timer = function(delay) {
                if (idle_timer != null)
                    clearTimeout(idle_timer);
                idle_timer = setTimeout(idle_handler, delay);
            }
            var non_idle_handler = function(evt) {
                console.log("non_idle_handler");
                init_idle_timer(miscConfig.idleModeDelayMs);
            }
            var idle_handler = function() {
                console.log("idle_handler");
                idleAction();
                init_idle_timer(miscConfig.idleModeDelayBetweenActionsMs);
            }

            document.body.addEventListener('mouseup', non_idle_handler, true);
            document.body.addEventListener('mousemove', non_idle_handler, true);
            document.body.addEventListener('mousedown', non_idle_handler, true);
            document.body.addEventListener("touchstart", non_idle_handler, true);
            document.body.addEventListener("touchend", non_idle_handler, true);
            document.body.addEventListener("touchcancel", non_idle_handler, true);
            document.body.addEventListener("touchmove", non_idle_handler, true);
            document.body.addEventListener("onscroll", non_idle_handler, true);

            init_idle_timer(miscConfig.idleModeDelayMs);
        }

        function idleAction() {
            bootbox.hideAll();
            nestedSwipers[(swiper.activeIndex + 2) % articles.length].slideTo(0, 0);
            swiper.slideNext(true, miscConfig.idleAnimationDurationMs);
        }

        function switchToSlider() {
            $('body > div').hide().filter('#slider').show();
        }

        function switchToViewer(which) {
            console.log(config);
            $('body > div').hide().filter('#showPdf').show();
        }

        var recipientName = '';
        var recipientAddress = '';

        function switchToMailMode(which) {
            bootbox.confirm({
                title: 'Please enter your email address',
                message: '<p>Select one of the input fields to open the on screen keyboard. Click outside the on screen keyboard to hide it.</p><br /><p><div class="form-group"><label for="emailName">Name:</label><input type="text" class="keyboard form-control" id="emailName"></div><div class="form-group"><label for="emailAddress">Email:</label><input type="text" class="keyboard form-control" id="emailAddress"></div></p>',
                callback: function(result) {
                    if (result) {
                        recipientName = $('#emailName').val().trim();
                        recipientAddress = $('#emailAddress').val().trim();
                        email(which);
                        recipientName = '';
                        recipientAddress = '';
                    }
                }
            });
            $("#emailName").keyboard();
            $("#emailAddress").keyboard();
        }

        function switchToPrintMode(which) {
            bootbox.confirm({
                title: 'Confirm printing',
                message: `<p class="dialog">Do you want to print: <em>"<b>${articles[which].authors.map( a => a.trim() ).join(", ")}:</b> ${articles[which].title.trim()}"</em>?<p>`,
                callback: function(result) {
                    if (result) {
                        print(which);
                    }
                }
            });
        }

        function print(which) {
            return new Promise((resolve, reject) => {
                console.log('printing ' + path.basename(articles[which].cachedPdf));
                streamBuffer = new streamBuffers.WritableStreamBuffer({
                    initialSize: (1000 * 1024), // start at 100 kilobytes.
                    incrementAmount: (100 * 1024) // grow by 10 kilobytes each time buffer overflows.
                });
                createPDFBooklet(articles[which].cachedPdf, streamBuffer);
                printer.printDirect({
                    data: streamBuffer.getContents(),
                    type: 'PDF',
                    options: {
                        landscape: true,
                        PageSize: 'A4',
                        Duplex: 'DuplexTumble'
                    },
                    success: resolve,
                    error: reject
                });
            });
        }

        function email(which) {
            var c = articles[which];

            console.log('mailing ' + c.url + ' to ' + recipientAddress);
            console.log(mailConfig.smtp);

            const substUrls = function(s) {
                return format(s, {
                    websiteUrl: c.url,
                    pdfUrl: c.pdf,
                    defaultRecipientName: recipientName != '' ? recipientName : mailConfig.defaultRecipientName
                });
            };

            var formattedHtml = substUrls(mailConfig.html);
            var formattedText = typeof mailConfig.text !== 'undefined' && mailConfig.text != null ? substUrls(mailConfig.text) : htmlToText.fromString(formattedHtml, {
                hideLinkHrefIfSameAsText: true
            });

            // setup e-mail data with unicode symbols
            var mailOptions = {
                from: {
                    name: mailConfig.senderName,
                    address: mailConfig.senderAddress
                }, // sender address
                to: recipientName == '' ? recipientAddress : {
                    name: recipientName,
                    address: recipientAddress
                }, // list of receivers
                subject: mailConfig.subject, // subject line
                text: formattedText, // plaintext body
                html: formattedHtml, // html body
            };

            // send mail with defined transport object
            transporter.sendMail(mailOptions, function(error, info) {
                if (error) {
                    bootbox.alert('Email could not be sent');
                    console.log(error);
                } else {
                    bootbox.alert('Email sent successfully');
                }
            });
        }

        $(document).ready(function() {
            var startTime = performance.now()
            rearrangeConfig();
            $("#progressCache").attr("total", articles.length);
            $("#progressDocs").attr("total", articles.length);
            initTopLevelSlides();
            initSliders();
            promises = [];
            articles.forEach((e, which, a) => {
                promise = initCache(which)
                    .then(which => {
                        increaseAttr("#progressCache", "num", 1);
                        return which;
                    })
                    .then(initDocument)
                    .then(which => {
                        increaseAttr("#progressDocs", "num", 1);
                        $("#progressPages").attr("total", totalNumPages);
                        $("#progressRendered").attr("total", totalNumPages);
                        return which;
                    })
                    .then(initNestedSlides)
                    .catch(e => {
                        disableSnapshot(which);
                        console.log("Problem processing snapshot", articles[which], e);
                    });
                promises.push(promise);
            });
            Promise.all(promises).then(() => {
                initComplete = true;
                $('#progress').hide();
                initIdleHandlers();
                switchToSlider();
                console.log(`loading took ${(performance.now()-startTime)/1000.0}s`)
            });
        });
    </script>
</body>

</html>
