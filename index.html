<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Swiper demo</title>
    <!-- Link Swiper's CSS -->
    <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="libs/jqbtk.min.css">
    <link rel="stylesheet" href="node_modules/swiper/dist/css/swiper.min.css">
    <link rel="stylesheet" href="node_modules/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="main.css">

    <!-- load some node.js packages -->
    <script>
        window.settings = require('electron-settings');
        settings.defaults(require("./defaults.json"));
        settings.applyDefaults({
            prettify: true
        });
        var miscConfig = settings.getSync("");
        var articles = miscConfig.snapshots.articles;
        var mailConfig = miscConfig.mail;
        if (typeof mailConfig.text !== "undefined" && mailConfig.text !== null)
            mailConfig.text = mailConfig.text.join("\n");
        if (typeof mailConfig.html !== "undefined" && mailConfig.html !== null)
            mailConfig.html = mailConfig.html.join("\n");

        window.$ = window.jQuery = require("jquery");
        require('bootstrap');
        window.bootbox = require('bootbox');
        require("swiper");
        window.qrImage = require("qr-image");

        window.nodemailer = require('nodemailer');
        window.htmlToText = require('html-to-text');
        window.format = require('string-template');

        require("pdfjs-dist");
        window.PDFJS.workerSrc = 'node_modules/pdfjs-dist/build/pdf.worker.js';

        // create reusable transporter object using the default SMTP transport
        window.transporter = nodemailer.createTransport(mailConfig.smtp);

        // verify connection configuration
        transporter.verify(function(error, success) {
            if (error) {
                console.log(error);
            } else {
                console.log('Server is ready to take our messages');
            }
        });

        window.fs = require('fs');
        window.fsExtra = require('fs-extra');
        window.path = require('path');
        window.childProcess = require('child_process');
        var request = require('request');
        var hummus = require('hummus');
        var streamBuffers = require('stream-buffers');
        var tempfile = require('tempfile');
        var printer = require('printer');

        function download(url, dest) {
            return new Promise((resolve, reject) => {
                console.log(`Downloading ${url} to ${dest}`);
                var file = fs.createWriteStream(dest);
                var sendReq = request.get(url);

                // verify response code
                sendReq.on('response', response => {
                    if (response.statusCode !== 200)
                        reject(new Error(`Download of ${url} failed with response code`));
                });

                // check for request errors
                sendReq.on('error', err => {
                    fs.unlink(dest);
                    reject(err);
                }); // Delete the file async. (But we don't check the result)

                sendReq.pipe(file);

                file.on('finish', () => file.close(() => resolve(dest))); // close() is async, call resolve after close completes.
                file.on('error', err => {
                    fs.unlink(dest);
                    reject(err);
                }); // Delete the file async. (But we don't check the result)
            });
        };

        function createPDF2On1(infile, outfileOrStream, pagesNumbers) {
            console.log(`Creating 2-on-1 version of ${infile} at ${outfileOrStream}`);
            if (typeof outfileOrStream !== 'string')
                outfileOrStream = new hummus.PDFStreamForResponse(outfileOrStream);
            var pdfWriter = hummus.createWriter(outfileOrStream, {
                version: eval("hummus.ePDFVersion" + hummus.createReader(infile).getPDFLevel() * 10)
            });
            var copyingContext = pdfWriter.createPDFCopyingContext(infile);
            var numPages = copyingContext.getSourceDocumentParser().getPagesCount();
            var pagesNumbers = (typeof pagesNumbers !== 'undefined') ? pagesNumbers : Array.from(Array(numPages), (_, i) => i);

            for (var i = 0; i < pagesNumbers.length;) {
                var page = pdfWriter.createPage(0, 0, 842, 595);
                var pageContent = pdfWriter.startPageContentContext(page);

                if (pagesNumbers[i] >= 0) {
                    pageContent.q().cm(1, 0, 0, 1, 0, 0);
                    copyingContext.mergePDFPageToPage(page, pagesNumbers[i]);
                    pageContent.Q();
                }
                ++i;
                if (i < pagesNumbers.length && pagesNumbers[i] >= 0) {
                    pageContent.q().cm(1, 0, 0, 1, 421, 0);
                    copyingContext.mergePDFPageToPage(page, pagesNumbers[i]);
                    pageContent.Q();
                }
                ++i;

                pdfWriter.writePage(page);
            }

            pdfWriter.end();
        }

        function createPDFBooklet(infile, outfileOrStream, shiftLastPageToBackCover = true) {
            console.log(`Creating booklet version of ${infile} at ${outfileOrStream}`);
            var numPages = hummus.createReader(infile).getPagesCount();
            var numBookletPages = Math.ceil(numPages / 4) * 4;

            // compute bookelt page numbers
            var pageNumbers = Array(0);
            var segment = [numBookletPages - 1, 0, 1, numBookletPages - 2];
            for (var i = 0; i < numBookletPages / 4; ++i) {
                pageNumbers = pageNumbers.concat(segment);
                segment = [segment[0] - 2, segment[1] + 2, segment[2] + 2, segment[3] - 2];
            }

            // move last page of input to last page of booklet if required
            if (shiftLastPageToBackCover) {
                pageNumbers = pageNumbers.map(i => i >= numPages - 1 ? -1 : i);
                pageNumbers[0] = numPages - 1;
            } else {
                pageNumbers = pageNumbers.map(i => i > numPages - 1 ? -1 : i);
            }
            createPDF2On1(infile, outfileOrStream, pageNumbers);
        }
    </script>
    <script src="libs/jqbtk.js"></script>
</head>

<body class="noselect">

    <div id="progress">
        PDF documents cached: <span id="progressCache">0</span>
        <br />PDF documents loaded: <span id="progressDocs">0</span>
        <br /> PDF pages loaded: <span id="progressPages">0</span>
        <br /> PDF pages rendered: <span id="progressRendered">0</span>
    </div>

    <!-- Swiper -->
    <div class="swiper-container swiper-container-h" id="slider">
        <div class="swiper-wrapper">
        </div>
    </div>

    <div id="sendEmail">
        Send E-Mail
        <a href="javascript:switchToSlider()">Hide</a>
        <a id="mailButton" href="">Mail</a>
        <p>
            Name:
            <input id="recipientName" width="100" />
        </p>
        <p>
            Address:
            <input id="recipientAddress" width="100" />
        </p>
    </div>

    <script>
        var swiper;
        var swiperInitialSlide;
        var nestedSwipers = [];

        function rearrangeConfig() {
            // reverse order such that oldest items come first
            articles.reverse();

            // put overview page to the beginning
            var frontPage = settings.getSync("snapshots.frontPage");
            frontPage.isFrontPage = true;
            articles.unshift(frontPage);

            // move ~half of the slides from the end to the beginning
            for (swiperInitialSlide = 0; swiperInitialSlide < Math.floor(articles.length / 2); ++swiperInitialSlide) {
                var elem = articles.pop();
                articles.unshift(elem);
            }
        }

        function fileExists(filePath) {
            try {
                return fs.statSync(filePath).isFile();
            } catch (err) {
                return false;
            }
        }

        function initCache() {
            var promises = [];
            var suffix = "pdfCache";
            var dirname = path.join(path.dirname(settings.getSettingsFilePath()), suffix);
            fsExtra.mkdirpSync(dirname, {
                mode: fs.statSync(path.dirname(settings.getSettingsFilePath())).mode
            });
            for (var i = 0; i < articles.length; ++i) {
                const c = articles[i];
                promises.push(new Promise(
                    function(resolve, reject) {
                        const resolve_wrapper = () => {
                            $('#progressCache').html(parseInt($('#progressCache').html(), 10) + 1 + ' of ' + articles.length);
                            resolve();
                        }
                        var basename = path.basename(c.pdf, ".pdf");
                        c.cachedPdf = path.join(dirname, `${basename}.pdf`);
                        downloadPromise = fileExists(c.cachedPdf) ? Promise.resolve(c.cachedPdf) : download(c.pdf, c.cachedPdf);
                        downloadPromise.catch(reject);
                        downloadPromise.then(resolve_wrapper);
                    }
                ));
            }
            var result = Promise.all(promises);
            result.then(function() {
                $('#progressCache').html($('#progressCache').html() + '. done');
            });
            return result;
        }

        function initSliders() {
            var lastActiveIndex = -1;
            var triggerAgain;
            var callback = function() {
                if (lastActiveIndex != swiper.activeIndex) {
                    console.log("reassigning slides");
                    $('slide-wrapper').css({
                        outline: 'none'
                    });
                    for (var i = swiper.activeIndex - 3; i <= swiper.activeIndex + 3; i++) {
                        const $slide = $(swiper.slides[i % swiper.slides.length]);
                        $(nestedSwipers[$slide.attr("data-swiper-slide-index")].container[0]).prependTo($slide.find(".slide-wrapper"));
                        console.log($slide.attr("data-swiper-slide-index") + " -> " + i % swiper.slides.length);
                    }
                    lastActiveIndex = swiper.activeIndex;
                }
                if (triggerAgain)
                    window.requestAnimationFrame(callback);
            }

            var swiperConfig = {
                direction: 'horizontal',
                slidesPerView: 'auto',
                freeMode: true,
                effect: 'coverflow',
                //mousewheelControl: true,
                //mousewheelForceToAxis: true,
                spaceBetween: 78,
                initialSlide: swiperInitialSlide,
                loop: true,
                loopedSlides: articles.length,
                freeModeSticky: true,
                freeModeMomentumRatio: 0.25,
                centeredSlides: true,
                onSlideChangeStart: function(swiper) {
                    triggerAgain = true;
                    window.requestAnimationFrame(callback);
                },
                onSlideChangeEnd: function(swiper) {
                    triggerAgain = true;
                },
            };
            swiper = new Swiper('#slider', swiperConfig);
            for (var i = 0; i < swiper.slides.length; i++)
                $(swiper.slides[i]).attr("data-swiper-fake-slide-index", i);

            var nestedSwiperConfig = {
                direction: 'vertical',
                slidesPerView: 'auto',
                spaceBetween: 4,
                freeMode: true,
                freeModeSticky: true,
                mousewheelControl: true,
                mousewheelForceToAxis: true,
                controlBy: 'container'
            };
            $(swiper.slides).not('.swiper-slide-duplicate').find('.swiper-container').each(function() {
                nestedSwipers.push(new Swiper(this, nestedSwiperConfig));
            });
            $(swiper.slides).filter('.swiper-slide-duplicate').find('.swiper-container').remove();
        }

        var documents = new Array(articles.length);
        var totalNumPages = 0;

        function initDocuments() {
            var promises = [];
            for (var i = 0; i < articles.length; ++i) {
                const local_i = i;
                var promise = PDFJS.getDocument(articles[local_i].cachedPdf).promise;
                promise.then(function(pdf) {
                    documents[local_i] = pdf;
                    totalNumPages += pdf.numPages;
                    $('#progressDocs').html(parseInt($('#progressDocs').html(), 10) + 1 + ' of ' + articles.length);
                });
                promises.push(promise);
            }
            var result = Promise.all(promises);
            result.then(function() {
                $('#progressDocs').html($('#progressDocs').html() + '. done');
            });
            return result;
        }

        function initSlides() {

            var pagePromises = [];
            var renderPromises = [];

            for (var i = 0; i < articles.length; ++i) {
                const slide = document.createElement("DIV");
                slide.classList.add("swiper-slide");
                slide.classList.add("swiper-slide-h");
                $("#slider").children(".swiper-wrapper").first().append(slide);
                const $slide_wrapper = $('<div/>', {
                    class: 'slide-wrapper'
                });
                $(slide).append($slide_wrapper);

                const verticalSwiper = $('<div class="swiper-container swiper-container-v" style="transform: translateZ(0);"><div class="swiper-wrapper"></div></div>');
                const verticalSwiperWrapper = verticalSwiper.children(".swiper-wrapper").first();

                const isFrontPage = typeof articles[i].isFrontPage != 'undefined' && articles[i].isFrontPage == true;

                $slide_wrapper.append(verticalSwiper);
                const buttonBar = $slide_wrapper.append(`<div id="button-bar-${i}" class="button-bar"></div>`).children().last();
                buttonBar.append(`<a href="javascript:switchToMailMode(${i});"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>`);
                if (isFrontPage)
                    buttonBar.append(`<i class="fa fa-print disabled" aria-hidden="true"></i>`);
                else
                    buttonBar.append(`<a href="javascript:switchToPrintMode(${i});"><i class="fa fa-print" aria-hidden="true"></i></a>`);

                // add QR code
                var svgObject = $(qrImage.imageSync(articles[i].url_short, {
                    type: 'svg',
                    size: 2
                }));
                svgObject.addClass("qrcode");
                $(`#button-bar-${i}`).append(svgObject);
                if (isFrontPage)
                    $(`#button-bar-${i}`).addClass('overview');

                const pdf = documents[i];

                for (var pageNum = 1; pageNum <= pdf.numPages; ++pageNum) {
                    const div = document.createElement("div");
                    div.classList.add("swiper-slide");
                    div.classList.add("swiper-slide-v");
                    const canvas = document.createElement("CANVAS");
                    canvas.style.transform = 'translateZ(0)';

                    canvas.width = $(slide).width();
                    div.appendChild(canvas);

                    const thisPageNum = pageNum;

                    verticalSwiperWrapper.append(div);

                    var pagePromise = pdf.getPage(pageNum).then(function(page) {
                        $('#progressPages').html(parseInt($('#progressPages').html(), 10) + 1 + ' of ' + totalNumPages);

                        var viewport = page.getViewport(1);
                        var scale = canvas.width / viewport.width;
                        var scaledViewport = page.getViewport(scale);
                        canvas.width = scaledViewport.width;
                        canvas.height = scaledViewport.height;

//                        var context = canvas.getContext("2d", {alpha: false});
                        var context = canvas.getContext("2d");
                        var renderContext = {
                            canvasContext: context,
                            viewport: scaledViewport
                        };

                        var renderPromise = page.render(renderContext).then(function() {
                            //$(canvas).replaceWith($('<img>').attr('src', canvas.toDataURL()));
                            $('#progressRendered').html(parseInt($('#progressRendered').html(), 10) + 1 + ' of ' + totalNumPages);
                        });
                        renderPromises.push(renderPromise);
                    });
                    pagePromises.push(pagePromise);
                }
            }

            return new Promise(function(resolve, reject) {
                Promise.all(pagePromises).then(function() {
                    $('#progressPages').html($('#progressPages').html() + '. done');
                    Promise.all(renderPromises).then(function() {
                        $('#progressRendered').html($('#progressRendered').html() + '. done');
                    }).then(resolve, reject);
                }, reject);
            });
        }

        function initIdleHandlers() {
            var idle_timer = null;
            var init_idle_timer = function(delay) {
                if (idle_timer != null)
                    clearTimeout(idle_timer);
                idle_timer = setTimeout(idle_handler, delay);
            }
            var non_idle_handler = function(evt) {
                console.log("non_idle_handler");
                init_idle_timer(miscConfig.idleModeDelayMs);
            }
            var idle_handler = function() {
                console.log("idle_handler");
                idleAction();
                init_idle_timer(miscConfig.idleModeDelayBetweenActionsMs);
            }

            document.body.addEventListener('mouseup', non_idle_handler, true);
            document.body.addEventListener('mousemove', non_idle_handler, true);
            document.body.addEventListener('mousedown', non_idle_handler, true);
            document.body.addEventListener("touchstart", non_idle_handler, true);
            document.body.addEventListener("touchend", non_idle_handler, true);
            document.body.addEventListener("touchcancel", non_idle_handler, true);
            document.body.addEventListener("touchmove", non_idle_handler, true);
            document.body.addEventListener("onscroll", non_idle_handler, true);

            init_idle_timer(miscConfig.idleModeDelayMs);
        }

        function idleAction() {
            bootbox.hideAll();
            nestedSwipers[(swiper.activeIndex + 2) % articles.length].slideTo(0, 0);
            swiper.slideNext(true, miscConfig.idleAnimationDurationMs);
        }

        function switchToSlider() {
            $('body > div').hide().filter('#slider').show();
        }

        function switchToViewer(which) {
            console.log(config);
            $('body > div').hide().filter('#showPdf').show();
        }

        var recipientName = '';
        var recipientAddress = '';

        function switchToMailMode(which) {
            bootbox.confirm({
                title: 'Please enter your email address',
                message: '<p>Select one of the input fields to open the on screen keyboard. Click outside the on screen keyboard to hide it.</p><br /><p><div class="form-group"><label for="emailName">Name:</label><input type="text" class="keyboard form-control" id="emailName"></div><div class="form-group"><label for="emailAddress">Email:</label><input type="text" class="keyboard form-control" id="emailAddress"></div></p>',
                callback: function(result) {
                    if (result) {
                        recipientName = $('#emailName').val().trim();
                        recipientAddress = $('#emailAddress').val().trim();
                        email(which);
                        recipientName = '';
                        recipientAddress = '';
                    }
                }
            });
            $("#emailName").keyboard();
            $("#emailAddress").keyboard();
        }

        function switchToPrintMode(which) {
            bootbox.confirm({
                title: 'Confirm printing',
                message: `<p class="dialog">Do you want to print: <em>"<b>${articles[which].authors.map( a => a.trim() ).join(", ")}:</b> ${articles[which].title.trim()}"</em>?<p>`,
                callback: function(result) {
                    if (result) {
                        print(which);
                    }
                }
            });
        }

        function print(which) {
            return new Promise((resolve, reject) => {
                console.log('printing ' + path.basename(articles[which].cachedPdf));
                streamBuffer = new streamBuffers.WritableStreamBuffer({
                    initialSize: (1000 * 1024), // start at 100 kilobytes.
                    incrementAmount: (100 * 1024) // grow by 10 kilobytes each time buffer overflows.
                });
                createPDFBooklet(articles[which].cachedPdf, streamBuffer);
                printer.printDirect({
                    data: streamBuffer.getContents(),
                    type: 'PDF',
                    options: {
                        landscape: true,
                        PageSize: 'A4',
                        Duplex: 'DuplexTumble'
                    },
                    success: resolve,
                    error: reject
                });
            });
        }

        function email(which) {
            var c = articles[which];

            console.log('mailing ' + c.url + ' to ' + recipientAddress);
            console.log(mailConfig.smtp);

            const substUrls = function(s) {
                return format(s, {
                    websiteUrl: c.url,
                    pdfUrl: c.pdf,
                    defaultRecipientName: recipientName != '' ? recipientName : mailConfig.defaultRecipientName
                });
            };

            var formattedHtml = substUrls(mailConfig.html);
            var formattedText = typeof mailConfig.text !== 'undefined' && mailConfig.text != null ? substUrls(mailConfig.text) : htmlToText.fromString(formattedHtml, {
                hideLinkHrefIfSameAsText: true
            });

            // setup e-mail data with unicode symbols
            var mailOptions = {
                from: {
                    name: mailConfig.senderName,
                    address: mailConfig.senderAddress
                }, // sender address
                to: recipientName == '' ? recipientAddress : {
                    name: recipientName,
                    address: recipientAddress
                }, // list of receivers
                subject: mailConfig.subject, // subject line
                text: formattedText, // plaintext body
                html: formattedHtml, // html body
            };

            // send mail with defined transport object
            transporter.sendMail(mailOptions, function(error, info) {
                if (error) {
                    bootbox.alert('Email could not be sent');
                    console.log(error);
                } else {
                    bootbox.alert('Email sent successfully');
                }
            });
        }

        $(document).ready(function() {
            rearrangeConfig();
            initCache().then(function() {
                initDocuments().then(function() {
                    initSlides().then(function() {
                        $('#progress').hide();
                        initSliders();
                        initIdleHandlers();
                        switchToSlider();
                    });
                });
            });
        });
    </script>
</body>

</html>
